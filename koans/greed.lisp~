(defpackage #:greed
  (:use #:cl))

(in-package #:greed)

(defclass dice-set ()
  ((dice-values :initarg :dice-values :accessor dice-values)))

(defmethod roll (count (object dice-set))
  (check-type count (integer (0)))
  (with-slots (dice-values) object
    (setf dice-values (loop :repeat count
                            :collect (1+ (random 6))))))

(defun score (&rest dice)
  (let* ((dice-list  (if (listp (car dice)) (car dice) dice))
         (counts (mapcar #'(lambda (x) (multiple-value-list (floor (count x dice-list) 3))) '(1 2 3 4 5 6)))
         (used-dice (mapcar #'(lambda (x y) (+ (if (> (first x) 0)
                                                   (* 3 (first x))
                                                   0)
                                               (if (or (= y 1) (= y 5))
                                                   (second x)
                                                   0)))
                            counts '(1 2 3 4 5 6))))

    (flet ((score-triples (lst idx)
             (let ((trip (first lst)))
               (cond ((= 1 idx) (* trip 1000))
                     (t         (* trip 100 idx)))))

           (score-singles (lst idx)
             (let ((singles (second lst)))
               (cond ((= 1 idx) (* 100 singles))
                     ((= 5 idx) (* 50 singles))
                     (t 0)))))

      (let ((total-score (loop :for lst :in counts
                               :for i :from 1 :upto 6
                               :sum (+ (score-triples lst i) (score-singles lst i)))))

        (list total-score (- (length dice-list) (reduce #'+ used-dice)))))))


(defclass player ()
  ((dice :initarg :dice :initform 5 :accessor dice )
   (score :initarg :score :initform 0 :accessor score)))


(let* ((dice '(1 1 1 2 3))
       (counts (mapcar #'(lambda (x) (multiple-value-list (floor (count x dice) 3))) '(1 2 3 4 5 6))))
  counts)

(defmethod play-turn ((p player))
  (let* ((initial-results (score (roll 5 (make-instance 'dice-set))))
         (initial-score (first initial-results))
         (remaining-dice (second initial-results)))

    (list initial-roll initial-results initial-score remaining-dice)))

(defun foo (&rest d)
  (let ((d-list (if (listp (car d)) (car d) d)))
    d-list))

(defun foo-1 (regex)
  (dotimes (i 100000)
    (ppcre:scan regex "Frunobulax")))

(defun foo-2 ()
  (dotimes (i 100000)
    (ppcre:scan "a|b+" "Frunobulax")))
